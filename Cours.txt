1. Ouvrir unity, créer un projet 3D


2. Sol et avion

Créer le sol : clic droit sur la scene, 3D object, plane. Reset sa position. Changer sa scale x et z pour 500. Renommer en sol.
Créer une capsule : clic droit sur la scene, 3D object, capsule. Ce sera l'avion. Reset la position, mettre 10 en Y. Mettre la rotation Z à 90. Rennomer en "avion".
En profiter pour régler les controles avec Edit/Preferences/Keys. Regler aussi les outils pour les placer sur AZERT
Créer des ailes pour l'avion en lui créer un enfant Cube, que l'on écrase. Mettre la position du cube à 0 puis le placer correctement pour qu'il ressemble à des ailes. Les ailes bougent avec la capsule.
Mettre la taille de l'avion à 5 10 5. Mettre la taille des ailes à 0.05 0.5 6.
Dans la fenetre assets, créer un material. Lui donner une couleur (albedo) plus agréable que le blanc. Renommer en "FloorMaterial". Déplacer sur le gameobject sol.
Sauvegarder la scene.
Se déplacer autour de l'avion pour prendre eun bon point de vue. Sélectionner la caméra. Faire GameObject / Align with view pour donner le bon angle à la camera.


3. Texture pour se repérer.

Sous paint, créer un carré de 256 * 256. Donner une bordure en haut et à gauche.
Importer dans unity.
Glisser la texture sur l'albedo. Mettre tiling à 50 * 50.


4. Faire avancer l'avion

Ajouter un composant RigidBody à l'avion. Tester.
Enlever la gravité.
Créer un composant script ShipMovement sur l'avion.

Déclarer le rigidbody dans le script :

    Rigidbody rbody;

Le récupérer pour pouvoir l'utiliser dans Start() : 

    rbody = GetComponent<Rigidbody>();

Donner une vitesse dans start :

    rbody.velocity = new Vector3(-10f, 0, 0);

On aimerait pouvoir régler la vitesse sans aller dans le code. Il suffit de créer un membre public Speed:

    public Vector3 Speed;

Et de rendre la vélocité égale à cette vitesse.

    rbody.velocity = speed;

On voit que la vitesse est désormais éditable dans Unity.


5. Controles : rotation de l'avion

On veut que l'avion tourne sur lui meme dans un sens ou dans l'autre quand on appuie sur Q ou D.

    if(Input.GetKey(KeyCode.Q))
    {
        // Rotation sur la gauche
    }
    if (Input.GetKey(KeyCode.D))
    {
        // Rotation sur la droite
    }

Le code pour la rotation :

    transform.Rotate(Vector3.up * rollSpeed * Time.deltaTime);

Avec rotateSpeed une nouvelle variable publique

Maintenant qu'on a la rotation le long de l'axe de l'avion, on veut le faire tourner vers le haut et vers le bas avec Z et S. Cela nous permettra de le controler l'avion.

    if (Input.GetKey(KeyCode.S))
    {
        transform.Rotate(Vector3.forward * -pitchSpeed * Time.deltaTime);
    }
    if (Input.GetKey(KeyCode.Z))
    {
        transform.Rotate(Vector3.forward * pitchSpeed * Time.deltaTime);
    }

Probleme : l'avion n'obeit pas du tout à sa rotation. Il continue à avancer selon l'axe X.


6. L'avion avance selon son angle

Calcul mathématique compliqué. Unity nous simplifie la tache.

    rbody.velocity = speed * (transform.rotation * Vector3.up) * Time.deltaTime;

Quand on fait transform.rotation * Vector3.up, il se déroule un beau calcul matriciel que l'on ne gère pas, et qui permet au devant de l'avion de correspondre à l'angle choisi.


7. L'avion est à peu pres controllable, mais il n'est pas suivi par la caméra.

Première solution : mettre la caméra comme enfant du vaisseau. Ca marche mais c'est moche. Sensations de jeu pas intéressantes.

Deuxième solution, un petit peu de code. On voudrait que la caméra "ratrappe" la position et l'angle de l'avion. Créer un script SmoothFollow pour la caméra.

public class SmoothFollow : MonoBehaviour
{
    public Transform target;

    public Vector3 velocity = Vector3.one;
    public Vector3 defaultDistance;
    public float distance;

    
    void LateUpdate()
    {
        if (!target) return;
        
        Vector3 toPosition = target.position + (target.rotation * defaultDistance);
        Vector3 currentPosition = Vector3.SmoothDamp(transform.position, toPosition, ref velocity, distance);
        transform.position = currentPosition;

        transform.LookAt(target);
    }
}

Propositions de valeurs :
Default distance 10 10 0
Distance 1.2


8. Tirer

Créer un objet vide enfant de l'avion, le nommer ShhotSpawnPoint et le placer sous l'avion.
Créer un Cylindre, le nommer shoot. Lui donner une taile de 1 5 1.
Faire glisser shoot dans la barre des assets. L'objet devient un prefab. On peut le supprimer de la scene.
Créer un script ShipShooting dans l'avion. OIn veut direr en appuyany sur espace. Pour tirer, on instancie notre objet de tir.

void Update () {
        if (Input.GetKey(KeyCode.Space))
        {
	Instantiate(shoot, position, rotation);
        }
}

Il faut quo'n puisse passer notre objet de tir: 

public GameObject shoot;

On peut maintenant glisser le prefab dans le slot shoot du script.

On veut la position de l'objet enfant (le deuxieme dans le hierarchie) et la rotation de l'avion.

Instantiate(shoot, transform.GetChild(1).position, transform.rotation);

Ca marche, mais les tirs ne bougent pas. On va leur ajouter un script qui leur donne une velocité. Qui doit être supérieure à celle de l'avion !

Créer un script Shoot dans le prefab Shoot. Créer aussi un Rigidbody pour qu'on puisse lui donner une vélocité. Ce rigidbody n'est pas soumis à la gravité. 
Recupérer le rigid body dans le script et leui donner une vélocité, parametrée par une vitesse publique.

Trois problèmes ! 
1. Les tirs s'éparpillent parce qu'ils se rentrent dedans.
2. Les tirs restent indéfiniment dans le jeu. Même si les objets sont simples, on risque de saturer la memoire.
3. Il y a trop de tirs. On genere une espece de spagetthis.



9. Régler les problèmes des tirs

Ca commence à être le bazar dans nos assets ! Créet un dossier script et mettre tous les scripts dedans. Unity gère l'association avec les GameObjects.

Problème 1 : les tirs s'éparpillent.
C'est parce que la physique du jeu fait interagir les tirs. Cocher isTrigger dans le composant collider du tir.

Problème 2 : les tirs demeurent. 
Ils ont une vitesse rapide donc deviennent très vite petits. On va leur donner une durée de vie de 3 secondes. Dans le script, ajouter :

        Destroy(gameObject, 4f);

Probleme 3 : les spagetthis.

La solution est de laisser s'écouler du temps entre chaque tir. Occupons nous de ShipShhoting.

On va créer un cooldown et un compteur qui s'incrémente avec le temps entre chaque frame. Quand ce temps depasse la durée du cooldown, on peut instancier un tir.